{"meta":{"title":"Godway's Studio","subtitle":"wsy","description":"","author":"Godway","url":"https://godway999.github.io","root":"/"},"pages":[{"title":"","date":"2019-05-04T05:26:26.023Z","updated":"2019-05-04T05:18:09.460Z","comments":true,"path":"google16734bd3d7a7f6df.html","permalink":"https://godway999.github.io/google16734bd3d7a7f6df.html","excerpt":"","text":"google-site-verification: google16734bd3d7a7f6df.html"},{"title":"Categories","date":"2019-05-03T13:47:27.000Z","updated":"2019-05-03T14:05:15.097Z","comments":true,"path":"categories/index.html","permalink":"https://godway999.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-03T13:44:33.000Z","updated":"2019-05-03T15:27:54.822Z","comments":true,"path":"tags/index.html","permalink":"https://godway999.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-12T16:00:43.000Z","updated":"2019-04-15T13:07:03.000Z","comments":true,"path":"about/index.html","permalink":"https://godway999.github.io/about/index.html","excerpt":"","text":"HelloWelcome to my studio!"}],"posts":[{"title":"计算机网络——第四章：网络层(数据平面)","slug":"Network4","date":"2019-05-14T11:43:37.000Z","updated":"2019-05-15T12:12:28.869Z","comments":true,"path":"2019/05/14/Network4/","link":"","permalink":"https://godway999.github.io/2019/05/14/Network4/","excerpt":"","text":"参考书目《计算机网络：自顶向下方法（第七版）》 网络层概述转发和路由选择：数据平面和控制平面 网络层能够分解为两个相互作用的部分：数据平面和控制平面 转发：当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路 转发是在数据平面中实现的唯一功能 转发（forwarding）是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作 转发发生的时间尺度很短（通常为几纳秒），因此常用硬件来实现 路由选择：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径 计算这些路径的算法被称为路由选择算法 路由选择（routing）是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程 路由选择发生的时间尺度很长（通常为几秒），因此常用软件来实现 网络服务模型 因特网的网络层提供了单一的服务模型，称为尽力而为服务（best-effort service） ATM网络体系结构提供了确保按序时延、有界时延和确保最小带宽 路由器工作原理 路由器四个组件：输入端口（input port）、交换结构（switch fabric）、输出端口（output port）、路由选择处理器（routing processor） 输入端口 它在路由器中值行终结入物理链路的物理层功能 它还要与位于入链路远端的数据链路层交互来执行数据链路层功能 更为重要的是，它还在输入端口值行查找功能，正是在这里通过查询转发表决定路由器的输出端口 输出端口 交换结构：交换结构将路由器的输入端口连接到它的输出端口 路由选择处理器：路由选择处理器执行控制平面功能 在传统的路由器中，它执行路由选择协议 在SDN路由器中，它负责与远程控制器通信 网际协议：IPv4、寻址、IPv6及其他通用转发和SDN","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://godway999.github.io/categories/计算机网络/"}],"tags":[]},{"title":"计算机网络——第三章：运输层","slug":"Network3","date":"2019-05-09T06:18:54.000Z","updated":"2019-05-16T06:12:07.820Z","comments":true,"path":"2019/05/09/Network3/","link":"","permalink":"https://godway999.github.io/2019/05/09/Network3/","excerpt":"","text":"参考书目《计算机网络：自顶向下方法（第七版）》 概述和运输层服务 网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信 运输协议能够提供的服务不一定受制于底层网络层协议的服务模型。例如，即使网络协议不可靠或不保证机密性，运输协议也能提供可靠的数据传输或加密服务 IP的服务模型是尽力而为(best-effort)交付服务，它不保证报文段的交付、按序到达或完整性。从而IP被称为不可靠服务 将主机间交付扩展到进程间交付被称为运输层的多路复用和多路分解 进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务 多路复用与多路分解 多路复用：从不同套接字中收集数据块并为每个数据块封装上首部信息生成报文段，之后将报文段传递到网络层 多路分解：运输层报文段中的数据交付到正确的套接字 主机使用IP地址和端口号来将报文段导向合适的套接字(socket) UDP的多路复用与多路分解 一个UDP套接字由一个二元组全面标识，该二元组包含一个目的IP地址和一个目的端口号 如果两个UDP报文段拥有不同的源IP地址或(/和)源端口号，但具有相同的目的IP地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程 TCP的多路复用与多路分解 一个TCP套接字由一个四元组(源IP地址，源端口号，目的IP地址，目的端口号)来标识的 两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初识创建连接的请求（例如Web服务器的80端口） Web服务器与TCP 连接套接字与进程之间并非总是有着一对一的关系；事实上。当今高性能Web服务器通常只使用一个进程，但是为每个新的客户连接创建一个具有新连接套接字的新线程 对于服务器来说，在任意给定时间都有可能有（具有不同标识的）许多连接套接字连接到相同的进程 无连接运输：UDP 运输层最低限度必须提供一种复用/分解服务，以便在网络层与正确的应用级进程之间传递数据 由[RFC 768]定义的UDP只是做了运输层协议能够做的最少工作 UDP被称为是无连接的，因为在发送报文段之前，发送方和接收方的运输层实体之间没有握手 许多使用UDP的原因 关于发送什么数据以及和何时发送的应用层控制更为精细 封装报文段的速度快 TCP会受到拥塞控制机制的遏制，而UDP不会。因为一些实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，且能容忍一些数据丢失 无须连接建立 UDP不需要任何准备即可进行数据传输。因此UDP不会引入建立连接的时延，这可能是DNS运行在UDP之上的主要原因 无连接状态 UDP不像TCP维护连接状态(接受和发送缓存、拥塞控制参数、序号和确认号的参数)。因而当某些应用程序运行在UDP之上而不是TCP之上时，一般都能支持更多的活跃客户 分组首部开销小 TCP每个报文段都有20字节的首部开销，而UDP仅有8字节 注意：使用UDP的应用是可能实现可靠数据传输的。这可通过在应用程序自身中建立可靠性机制来完成(谷歌的Chrome浏览器使用的QUIC协议在UDP之上的应用层协议中实现了可靠性) UDP报文结构 长度字段指明了包括首部在内的UDP报文段长度（以字节为单位） 检验和(checksum)用于差错检测功能 发送方对报文段中的所有16比特字(检验和的位置被认为是全0)进行求和（求和时的溢出都被回卷），将结果的和进行反码运算并存为UDP报文段中的检验和 接收方只要将全部的16比特字(包括检验和)进行相加，若结果不全为1，则表示该分组中出现了差错 计算检验和的时候不足16比特字时使用0填充(zero padding) 提供检验和的原因是：不能保证源和目的之间的所有链路都提供差错检测 端到端原则：某些功能(例如差错检测)必须基于端到端实现，因为“与在较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余的或几乎没有价值的” 可靠数据传输原理可靠数据传输为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。实现这种抽象的是可靠数据传输协议(reliable data transfer, rdt) 可靠数据传输机制及其用途的总结 检验和：用于检测在一个传输分组中的比特错误 确认(ACK)：接收方用于告诉发送方一个分组或一组分组已经被正确的接收到了 确认报文通常携带着被确认的分组或多个分组的序号 确认报文可以是逐个的或累积的，这取决于协议 序号：用于为从发送方流向接收方的数据分组按顺序编号 所接收分组的序号间的空隙可使接收方检测出丢失的分组 具有相同序号的分组可使接收方检测出一个分组的冗余副本 否定确认(NAK)：接收方用于告诉发送方某个分组未被正确的接收。 冗余ACK(duplicated ACK)：用于实现与NAK一样的效果 定时器：用于超时/重传一个分组，因为该分组(或其ACK)在信道中丢失了 由于当一个分组延时但未丢失(过早超时)，或当一个分组已被接收方收到但从接受方到发送方的ACK丢失时，可能产生超时事件，所以接受方可能会收到一个分组的多个冗余副本 窗口、流水线：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。 通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。 窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度来进行设置 流水线可靠数据传输协议 假定发送速率为$R$bps，所有分组长度为$L$比特，定义信道利用率为：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比 U_{sender} = \\frac{\\frac{L}{R}}{RTT + \\frac{L}{R}} 使用流水线可以显著增加信道利用率，其中$W$表示窗口大小 U_{sender} = \\frac{W \\times \\frac{L}{R}}{RTT + \\frac{L}{R}} 流水线要求每个输送中的分组(不计算重传)必须有一个唯一的序号；协议的发送方和接收方也许不得不缓存多个分组 解决流水线差错恢复有两种基本方法：回退N步(GBN)和选择重传(SR) 流水线差错恢复：GBN(Go-Back-N) 基序号（send_base）：最早未确认分组的序号 下一个序号（nextseqnum）：最小的未使用序号（即下一个待发分组的序号） N被称为窗口长度（window size），因而GBN协议也被称为滑动窗口协议 四个区间： 区间[0, send_base - 1]内的序号对应用于已经发送并被确认的分组 区间[send_base, nextseqnum - 1]内的序号对应已被发送但未被确认的分组 区间[nextseqnum, send_base + N - 1]内的序号能用于那些要被立即发送的分组 大于等于send_base + N的序号是不能使用的 GBN发送方需响应三种类型的事件 上层的调用 收到一个ACK 超时事件 GBN对序号为n的分组的确认采取累计确认 GBN接收方丢弃所有失序分组，并不缓存失序分组，其所需要维护的唯一信息就是下一个按序接收的分组的序号 丢弃一个正确接收的分组的缺点是随后对该分组的重传也许会丢失或出错，因此甚至需要更多的重传 流水线差错恢复：SR(Selective Repeat) 选择重传(SR)协议通过让发送方仅重传那些它怀疑在接收方丢失或受损的分组而避免了不必要的重传 SR接收方确认一个正确接收的分组而不管其是否按序 注意： 接收方对于收到的序号小于当前窗口基序号的分组，需要重新回复一个ACK确认(而不是忽略他们)。因为对于SR协议，发送方和接收方的窗口并不总是一致的。 由于发送方和接收方的窗口不一定是一致的，从而窗口长度必须小于或等于序号空间大小的一半 面向连接的运输：TCP TCP提供的是全双工(数据可以双向传输)、点对点(连接仅限于两台主机)的服务 MTU，即最大传输单元(Maximum Transmission Unit)，表示物理接口(数据链路层)提供给其上层(通常是IP层)单次最大传输数据的大小，也表示从源到目的地的所有链路上发送的最大链路层帧 MSS，即最大报文段长度(Maximum Segment Size)，表示TCP提交给网络层最大分段的大小，指报文段里数据的最大长度，不是指包括首部的TCP报文段的最大长度 MSS是TCP用来限制应用层的最大发送字节数，是TCP能发送的分组的最大长度 MSS是系统默认的,就是系统TCP/TP栈所能允许的最大包。在建立连接时,这个值已经确定了,这个值并不是客观的值,而是由TCP/IP的实现确定的 以太网和PPP链路层协议都具有1500字节的MTU，因此MSS的典型值为1460字节（1500 - 20(IP首部）- 20(TCP首部) = 1460） TCP报文结构 序号(Seq)：序号建立在传送的字节流之上，因此一个报文段的序号是该报文段首字节的字节流编号 TCP连接的双方均可随机地选择初始序号 确认号(ACK)：主机A填充进报文段的确认号是主机A期待从主机B收到的下一字节的编号 TCP使用累计确认 往返时间的估计与超时 TCP使用超时/重传机制来处理报文段的丢失 SampleRTT：某报文段被交给网络层到对该报文段的确认被收到之间的时间量 EstimatedRTT：对SampleRTT使用指数加权移动平均得到，$\\alpha$的推荐值为0.125 EstimatedRTT = (1 - \\alpha) \\times EstimatedRTT + \\alpha \\times SampleRTT DevRTT：用于估计SampleRTT偏离EstimatedRTT的程度 DevRTT = (1 - \\beta) \\times DevRTT + \\beta \\times |SampleRTT - EstimatedRTT| TimeoutInterval定义为经验上的TCP超时重传间隔，推荐的初始值为1秒 TimeoutInterval = EstimatedRTT + 4 \\times DevRTT流量控制流量控制的目的是为了消除发送方使接收方缓存溢出的可能性 TCP连接管理 建立TCP连接的三次握手： 第一步：客户端的TCP首先向服务端发送SYN报文段，其中SYN比特被置为1，同时客户会随机选择一个初始序号Seq（client_isn）并封装到该报文段中 第二步：服务端回复SYNACK报文段，其中SYN比特被置为1，该报文段的ACK被置为client_isn + 1，最后服务端选择自己的初始序号Seq（server_isn）并封装到该报文段中 客户端对收到SYNACK报文段进行回复。将该报文的ACK置为server_isn + 1，同时将SYN比特置为0。第三次握手可以在报文段负载客户端到服务端的数据 断开TCP连接的四次挥手： 客户端发送FIN给服务端 服务端收到FIN并回复ACK，并发送FIN，准备关闭连接 客户端收到FIN并回复ACK，并发送FIN，然后关闭连接 服务端收到ACK，关闭连接 拥塞控制原理 网络拥塞的代价： 分组的到达速率接近链路容量时，分组将经历巨大的排队时延 发送方必须执行重传以补偿因为缓存一出而丢弃（丢失）的分组 发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本 当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了 拥塞控制方法： 端到端拥塞控制。端系统需对网络行为的观察（如丢失与时延）来推断网络状况。如TCP 网络辅助的拥塞控制。在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。如显式拥塞控制ECN TCP拥塞控制一图胜千言。。。 一条连接的平均吞吐量 = \\frac{1.22 \\times MSS}{RTT \\sqrt{L}}","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://godway999.github.io/categories/计算机网络/"}],"tags":[]},{"title":"计算机网络——第二章：应用层","slug":"Network2","date":"2019-05-07T12:41:41.000Z","updated":"2019-05-19T08:40:30.538Z","comments":true,"path":"2019/05/07/Network2/","link":"","permalink":"https://godway999.github.io/2019/05/07/Network2/","excerpt":"","text":"参考书目《计算机网络：自顶向下方法（第七版）》 应用层协议原理 网络核心设备并不在应用层上起作用，而仅在较低层起作用，特别是在网络层及下面层次起作用 网络应用程序体系结构： 客户-服务器体系结构 P2P体系结构（优秀的特点自扩展性） 可供应用程序使用的传输服务 可靠数据传输 吞吐量 定时（能在给定时间内完成通信） 安全性 TCP服务： 面向连接的服务 可靠的数据传输服务 流量控制 拥塞控制 不提供：定时、最小吞吐量保证、安全性 UDP服务 仅提供最小服务 不可靠数据传输服务 到达接受进程的报文可能是乱序到达 应用层协议定义了运行在不同端系统上的应用进程如何相互传递报文，特别是其定义了： 交换的报文类型，例如请求报文和响应报文 各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的。 字段的语义，即这些字段中的信息的含义 确定一个进程何时以及如何发送报文，对报文进行响应的规则 Web和HTTP Web的应用层协议是超文本传输协议(HyperText Transfer Protocol, HTTP)，定义在[RFC 1945]和[RFC 2616] 每个URL地址由两部分组成：存放对象的服务器主机名和对象的路径名 Web浏览器——&gt;HTTP的客户端，Web服务器———&gt;HTTP的服务器端。Web服务器用于存储Web对象，每个对象由URL寻址 HTTP定义了Web客户与Web服务器间间的Web页面的交互方式 因为HTTP服务器不保存关于客户的任何信息，所以HTTP是一个无状态协议 HTTP连接方式：持续连接和非持续连接 对于持续连接： 每次总的响应时间为2个RTT加上服务器传输HTML文件的时间（三次握手+文件传输） 缺点： 必须为每个请求的对象建立和维护一个全新的连接 每个对象经受两倍RTT的交付时延 HTTP默认模式是使用带流水线的持续连接 HTTP报文有两种：请求报文和响应报文 请求报文结构：请求行、首部行、实体 请求行：方法(GET,POST,HEAD,PUT,DELETE)、URL、HTTP版本 响应报文结构：状态行、首部行、实体 状态行包括协议（HTTP）版本、状态码、状态信息 常见状态码和相关短语： 200 OK：请求成功，信息在返回的响应报文中 301 Moved Permanently：请求的对象已被永久转移，新的URL定义在响应报文中 400 Bad Request：该请求不能被服务器理解 404 Not Found：被请求的文档不在服务器上 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本协议 由于HTTP服务器是无状态的，然而有些时候Web站点希望能够识别用户，为此HTTP使用了cookie，它允许站点对用户进行跟踪 Web缓存器也叫代理服务器，它是能够代表初始Web服务器来满足HTTP请求的网络实体 部署Web缓存器的两个理由： 可以大大减少对客户请求的响应时间，特别是当客户与目标服务器之间的瓶颈带宽远低于客户与Web缓存器之间的瓶颈带宽时 可以大大减少一个机构的接入链路到因特网的通信量，使其不必急于增加带宽，从而降低费用 条件GET方法：用于判断缓存在代理服务器上的内容是否是最新的 因特网中的电子邮件 因特网电子邮件系统有三个主要组成部分： 用户代理(user agent) 邮件服务器(mail server) 简单邮件传输协议(Simple Mail Transfer Protocol, SMTP) SMTP用于从发送方的邮件服务器发送报文到接收方的邮件服务器 SMTP限制所有邮件报文的体部分（不只是其首部）只能采用简单的7比特ASCII表示 SMTP一般不使用中间邮件服务器发送邮件，即使这两个邮件服务器位于地球的两端 SMTP与HTTP的对比： HTTP主要是一个拉协议(pull protocol)，用户使用HTTP从服务器上拉取信息；SMTP基本上是一个推协议(push protocol)，发送邮件服务器把文件推到接收邮件服务器 SMTP要求每个报文采用7比特ASCII码格式；HTTP则不受这种限制 HTTP把每个对象封装到它自己的HTTP响应报文中；SMTP则把所有报文对象放在一个报文中 DNS：因特网的目录服务 主机可以用主机名(hostname)标识，如www.google.com；也可以通过IP地址进行标志 域名系统(Domain Name System, DNS)的主要任务是提供一种能进行主机名到IP地址转换的目录服务 DNS是： 一个由分层的DNS服务器实现的分布式、层次数据库 一个使得主机能够查询分布式数据库的应用层协议 DNS运行在UDP之上，使用53号端口 DNS还提供一些别的重要服务： 主机别名 邮件服务器别名（像google邮箱可以使用很多的别名） 负载均衡（使用冗余服务器） DNS层次结构 根DNS服务器：提供TLD服务器的IP地址 顶级域(Top-Level Domain, TLD)DNS服务器：提供权威服务器的IP地址 权威DNS服务器：提供公共可访问主机的IP地址 DNS查询有迭代和递归两种方式 由于DNS缓存，除少数DNS查询以外，根服务器都被绕过了 P2P文件分发 在P2P文件分发中，每个对等方能够向任何其他对等方重新分发他已经收到的文件的任何一部分 优点：自扩展性 视频流和内容分发网CDN&amp;&amp;&amp;st=>start: 请求主机 op1=>operation: 本地DNS服务器 op2=>operation: 根DNS服务器 op3=>operation: TLD DNS服务器 op4=>operation: 权威DNS服务器 op5=>operation: 本地DNS服务器 e=>end: 请求主机 st->op1->op2->op3->op4->op5->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://godway999.github.io/categories/计算机网络/"}],"tags":[]},{"title":"计算机网络——第一章：计算机网络和因特网","slug":"Network1","date":"2019-05-07T12:41:31.000Z","updated":"2019-05-10T07:52:22.485Z","comments":true,"path":"2019/05/07/Network1/","link":"","permalink":"https://godway999.github.io/2019/05/07/Network1/","excerpt":"","text":"参考书目《计算机网络：自顶向下方法（第七版）》 什么是因特网 通常把与因特网相连的计算机和其他设备称为端系统 端系统通过通信链路和分组交换机连接在一起 分组交换机：路由器和链路层交换机 链路层交换机通常用于接入网，而路由器通常用于网络核心中 端系统通过因特网服务提供商(Internet Service Provider, ISP)接入因特网 因特网标准(Internet Standard)由因特网工程任务组(Internet Engineering Task, Force, IETF)研发，IETF的标准文档称为请求评论(Request For Comment, RFC) 网络边缘 接入网是指将端系统物理连接到其边缘路由器的网络 家庭接入：数字用户线(Digital Subscriber Line, DSL)、电缆、光纤到户(Fiber To The Home, FTTH)、拨号和卫星 企业(和家庭接入)：以太网、WiFi 广域无线接入：4G和LTE 因特网传输的物理媒介： 导引型媒介：双绞铜线、同轴电缆、光纤 非导引型媒介：陆地无线电信道、卫星无线电信道 网络核心通过网络链路和交换机移动数据有两种基本方法：电路交换和分组交换 分组交换 源将长报文划分为较小的数据块，称之为分组 多数分组交换机在链路的输入端使用存储转发机制，存储转发传输是指在交换机能够开始向链路传输该分组的第一个比特之前，必须接收到整个分组 分组交换网路采用统计复用(Statistical Multiplexing)原则，意味着在一个处理节点，数据包分组的到达的分布是符合统计学分布(泊松分布)；基于统计复用的系统，就叫做排队系统 对于每条相连的链路，该分组交换机具有一个输出缓存(也称为输出队列)，它用于存储路由器准备发往那条链路的分组。 分组可能需要承担存储转发时延、排队时延甚至分组丢失 每台路由器具有一个转发表，用于目的地址（或目的地址的一部分）映射成为输出链路。路由选择协议用于自动的设置这些转发表 电路交换 在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）；在分组交换网络中是不预留的 链路中的电路是通过频分复用(FDM)或时分复用(TDM)来实现的，如下图所示 对于FDM 在连接期间链路为每条连接分配一个专用频段，该频段的宽度称为带宽 个人理解：将总带宽根据用户人数划分给每个用户，每个用户只分得总带宽的一部分，但所有用户同一时间互不干扰 对于TDM 时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙，网络在每个帧中为每个连接指定一个时隙，该时隙专门由该连接单独使用 个人理解：类似于操作系统中CPU轮转调度，每个连接轮着使用，并在使用期间内独享物理最大带宽 从而对于TDM，一条电路的传输速率等于帧速率乘以一个时隙中的比特数量 分组交换与电路交换的对比 电路交换在静默期中电路资源被浪费了；创建端到端电路和预留端到端带宽是复杂的 分组交换不适合实时服务，因为它的端到端时延是可变的和不可预测的 分组交换提供了比电路交换更好的带宽共享,允许更多的用户使用网络；它比电路交换更简单、更有效、实现成本更低 分组交换网络中的时延、丢包和吞吐量时延概述 时延类型： 处理时延($d_{proc}$)：检查分组首部、确定分组去向、检查差错等 排队时延($d_{queue}$)：分组在队列中等待被传输的时间 传输时延($d_{trans}$)：接收到整个分组的时间用$L$比特表示分组的长度，用$R$bps表示从路由器A到路由器B的链路传输速率，则传输时延为$\\frac{L}{R}$ 传播时延($d_{prop}$)：一个比特从链路的起点到到终点在媒介中传播所需的时间 节点总时延 d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop} 排队时延和丢包 排队时延对于不同的分组可能是不同的 令$a$表示分组到达队列的平均速率(a的单位为分组/秒，即pkt/s)，传输速率$R$bps，假定所有分组长度为$L$比特，则比特到达队列的平均速率是$La$bps；再假设队列容量为无穷，则流量强度定义为$\\frac{La}{R}$ 平均排队时延与流量强度的关系如下 $\\frac{La}{R} \\rightarrow 0$平均排队时延很小 $\\frac{La}{R} \\rightarrow 1$排队时延趋进于无穷 实际中队列容量是有限的，因而当队列容量满时，路由器将丢弃新到达的分组，也就是丢包 吞吐量 瞬间吞吐量指主机在某一时刻接受文件的速率 平均吞吐量$\\frac{F}{T}$bps表示接收到所有$F$比特用了$T$秒 吞吐量取决于数据流过的链路的传输速率。也就是说，其近似为沿着源和目的地之间路径的最小传输速率 协议层次及其服务模型 分层的优点 改变服务的实现而不影响该系统其他组件(利于维护更新) 简化网络系统 分层的缺点 高层可能冗余较低层的功能(例如许多协议在基于每段链路和基于端到端两种情况下，都提供了差错恢复) 某层的功能可能需要仅在其他某层才出现的信息(如时间戳值)，这违反了层次分离的目标 5层协议栈 自上而下 载体 协议 应用层 message FTP,SMTP,HTTP 运输层 segment TCP,UDP 网络层 datagram/packet IP,路由协议 链路层 frame PPP,以太网 物理层 bit/Byte - 在每一层，一个分组具有两种两种类型的字段：首部字段和有效载荷字段。有效载荷通常是来自上一层的分组","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://godway999.github.io/categories/计算机网络/"}],"tags":[]},{"title":"Markdown中Latex常用符号","slug":"Others1","date":"2019-05-04T08:24:28.000Z","updated":"2019-05-05T12:18:19.571Z","comments":true,"path":"2019/05/04/Others1/","link":"","permalink":"https://godway999.github.io/2019/05/04/Others1/","excerpt":"","text":"参考转载出处 常用希腊字母表 Name Display Capital Case Display Var Case Display \\alpha $\\alpha$ \\beta $\\beta$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\theta $\\theta$ \\Theta $\\Theta$ \\vartheta $\\vartheta$ \\mu $\\mu$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ \\varepsilon $\\varepsilon$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\varsigma $\\varsigma$ \\pi $\\pi$ \\Pi $\\Pi$ \\varpi $\\varpi$ \\omega $\\omega$ \\Omega $\\Omega$ \\xi $\\xi$ \\Xi $\\Xi$ \\zeta $\\zeta$ \\chi $\\chi$ \\rho $\\rho$ \\varrho $\\varrho$ \\phi $\\phi$ \\Phi $\\Phi$ \\varphi $\\varphi$ \\eta $\\eta$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\kappa $\\kappa$ \\nu $\\nu$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\psi $\\psi$ \\Psi $\\Psi$ \\tau $\\tau$ \\iota $\\iota$ o $o$ 常用特殊字符表 Name Display Name Display Name Display Name Display \\times $\\times$ \\div $\\div$ \\pm $\\pm$ \\mp $\\mp$ \\otimes $\\otimes$ \\ominus $\\ominus$ \\oplus $\\oplus$ \\odot $\\odot$ \\oslash $\\oslash$ \\triangleq $\\triangleq$ \\ne $\\ne$ \\equiv $\\equiv$ \\lt $\\lt$ \\gt $\\gt$ \\le $\\le$ \\ge $\\ge$ \\cup $\\cup$ \\cap $\\cap$ \\Cup $\\Cup$ \\Cap $\\Cap$ \\bigcup $\\bigcup$ \\bigcap $\\bigcap$ \\ast $\\ast$ \\star $\\star$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\circ $\\circ$ \\bullet $\\bullet$ \\bigcirc $\\bigcirc$ \\amalg $\\amalg$ \\to $\\to$ \\infty $\\infty$ \\vee $\\vee$ \\wedge $\\wedge$ \\lhd $\\lhd$ \\rhd $\\rhd$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\unlhd $\\unlhd$ \\unrhd $\\unrhd$ \\sqcap $\\sqcap$ \\sqcup $\\sqcup$ \\prec $\\prec$ \\succ $\\succ$ \\subset $\\subset$ \\supset $\\supset$ \\sim $\\sim$ \\approx $\\approx$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\cong $\\cong$ \\doteq $\\doteq$ \\setminus $\\setminus$ \\mid $\\mid$ \\ll $\\ll$ \\gg $\\gg$ \\parallel $\\parallel$ \\Join $\\Join$ \\in $\\in$ \\notin $\\notin$ \\propto $\\propto$ \\neg $\\neg$ \\ldots $\\ldots$ \\cdots $\\cdots$ \\forall $\\forall$ \\exists $\\exists$ \\vdots $\\vdots$ \\ddots $\\ddots$ \\aleph $\\aleph$ \\nabla $\\nabla$ \\imath $\\imath$ \\jmath $\\jmath$ \\ell $\\ell$ \\partial $\\partial$ \\int $\\int$ \\oint $\\oint$ \\uplus $\\uplus$ \\biguplus $\\biguplus$ 其他符号 Name Display Name Display \\triangleleft $\\triangleleft$ \\triangleright $\\triangleright$ \\bigtriangleup $\\bigtriangleup$ \\bigtriangledown $\\bigtriangledown$ \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\leftarrow $\\leftarrow$ \\rightarrow $\\rightarrow$ \\Leftarrow $\\Leftarrow$ \\Rightarrow $\\Rightarrow$ \\longleftarrow $\\longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longleftarrow $\\Longleftarrow$ \\Longrightarrow $\\Longrightarrow$ \\leftrightarrow $\\leftrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ \\leftharpoonup $\\leftharpoonup$ \\rightharpoonup $\\rightharpoonup$ \\leftharpoondown $\\leftharpoondown$ \\rightharpoondown $\\rightharpoondown$ \\rightleftharpoons $\\rightleftharpoons$ \\S $\\S$ \\nwarrow $\\nwarrow$ \\nearrow $\\nearrow$ \\swarrow $\\swarrow$ \\searrow $\\searrow$ \\triangle $\\triangle$ \\box $\\Box$ \\diamond $\\diamond$ \\diamondsuit $\\diamondsuit$ \\heartsuit $\\heartsuit$ \\clubsuit $\\clubsuit$ \\spadesuit $\\spadesuit$","categories":[{"name":"Others","slug":"Others","permalink":"https://godway999.github.io/categories/Others/"}],"tags":[{"name":"Mardown","slug":"Mardown","permalink":"https://godway999.github.io/tags/Mardown/"}]},{"title":"Mac本地用Eclipse配置NS3开发环境(完整教程)","slug":"NS3_1","date":"2019-05-03T13:48:29.000Z","updated":"2019-05-06T12:03:14.119Z","comments":true,"path":"2019/05/03/NS3_1/","link":"","permalink":"https://godway999.github.io/2019/05/03/NS3_1/","excerpt":"","text":"前言 这段时间接触了NS3，发现这个框架在计算机网络领域用的还是蛮多的，在本地搭建开发环境的过程中也遇到了不少坑，这里记录一下整个过程。 在终端下编译和运行NS3程序 NS3的下载和编译NS3官网上给的过程已经很详细了，这里简要概述一下。官放一共提供了三种方法:build.py,bake,waf。个人推荐使用waf编译整个项目（官方文件中自带waf编译器），因为前两种涉及到好多python环境的依赖，我觉得容易出问题。 在我的Mac上由于使用clang++，一定要加上--disable-werror，如果需要搭建python3的开发环境，需要指明python3具体位置。 123cd (本地存放位置)/ns-allinone-3.29/ns-3.29/./waf --enable-test --build-profile=debug --python=/usr/local/bin/python3 --with-python=python3 --disable-werror configure./waf build 经过一段时间的编译之后，在当前目录下运行一个官方例程scratch-simulator，如果一切顺利可以看到程序输出一行Scratch Simulator 1./waf --run scratch/scratch-simulator 在Eclipse上配置NS3开发环境 作为一个新手，如果没有一个友好的开发环境，很容易就进入从入门到放弃的阶段。NS3最让我不能接受的是必须用官方给的waf编译代码，我一开始尝试在Xcode搭建环境，然而Xcode好像对于使用外部编译器的支持不是很好，最终我还是转到在Eclipse上搭建开发环境。 在Eclipse上新建项目按如下顺序File -&gt; New -&gt; C/C++ Project，创建C++项目着重强调！！！NS3的代码必须放到(本地存放位置)/ns-allinone-3.29/ns-3.29/scratch/文件夹下才能被正确编译执行所以工程位置放在(本地存放位置)/ns-allinone-3.29/ns-3.29/,这里工程名字自己定，我这里取名为NS3，右侧的编译器随便选一个，之后点finish完成。 编译NS3项目如果前一步没遇到问题，现在左侧的工程目录应该基本长这样子，以后就直接在scratch目录下新创xxx.cc文件就好了。之后这里右键NS3文件夹，进入工程属性面板。右侧点击C/C++ Build然后照我的样子配置两处。编译器类型记得选为外部编译器，编译器选为当前目录下的waf编译器，编译结果放在当前目录下的build文件夹中之后进入到(本地存放位置)/ns-allinone-3.29/ns-3.29/进行configure操作，如果之前已经configure过了可以跳过该步骤。 12cd (本地存放位置)/ns-allinone-3.29/ns-3.29/./waf --enable-test --build-profile=debug --python=/usr/local/bin/python3 --with-python=python3 --disable-werror configure configure过了之后点击Eclipse左上角的Build按钮就可以编译整个NS3工程了 配置Eclipse使用外部编译器waf构建完了整个NS3工程之后，我们后续怎么运行我们自己写的代码呢？这时候需要配置使用外部编译器waf。在Eclipse顶部按如下顺序Run -&gt; Extern Tools -&gt; Extern Tools Configurations左侧右键点击新建一个编译器。我这里将这个外部编译器取名为ns3-waf，其余两个和之前一样，参数这里填写--run &quot;${string_prompt}&quot;这里点掉这个Build before launch选项之后点击Eclipse上方红色方框内的按钮然后会弹出一个选项框让填写你要编译的文件的名称，注意这里不用加.cc后缀,比如我要编译运行scratch文件夹下的scratch-simulator.cc，就直接填写scratch-simulator或scratch/scratch-simulator。如果你的自己写的文件之前已经build过了，就不需要再加文件目录scratch/，直接填写文件名就好。下方显示运行结果 配置NS工程路径此时虽然能够运行自己写的NS3代码了，但是代码中却还有一堆烦人的下波浪线〰️，并且头文件的引用等都是查询不到的，这里就需要配置一下NS3工程路径和环境。和之前一样，首先进入属性面板。然后找到图中所示的配置目录这一步将(本地存放位置)/ns-allinone-3.29/ns-3.29/build/ns3/下所有工程头文件包含了进来。然后构建会花费一小会时间，之后可以在左侧NS3/includes/下看到新生成了一个NS3/build/ns3文件，然后代码中的波浪线就全部消失了 配置完成","categories":[{"name":"NS3","slug":"NS3","permalink":"https://godway999.github.io/categories/NS3/"}],"tags":[]},{"title":"数据库原理——第七章：数据库设计","slug":"Database7","date":"2019-05-03T11:42:57.000Z","updated":"2019-05-21T08:12:05.410Z","comments":true,"path":"2019/05/03/Database7/","link":"","permalink":"https://godway999.github.io/2019/05/03/Database7/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 数据库设计概述需求分析概念结构设计逻辑结构设计物理结构设计","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第六章：关系数据库理论","slug":"Database6","date":"2019-04-27T11:42:54.000Z","updated":"2019-05-21T10:53:51.276Z","comments":true,"path":"2019/04/27/Database6/","link":"","permalink":"https://godway999.github.io/2019/04/27/Database6/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 问题的提出 针对一个具体的问题，应该如何构建一个适用于它的数据库模式，即应该构建几个关系模式，每个关系由哪些属性组成等。这是数据库设计的问题，确切地讲是关系数据库逻辑设计问题（如何构造合适的数据模式）。 数据依赖是一个关系内部属性与属性之间的约束关系，这种约束关系是通过属性值的相等与否体现出来的数据间相关联系。 一个好的关系模式不会发生插入异常、删除异常和更新异常，数据冗余尽可能的少。 规范化 定义：若属性组$X$能唯一确定属性组$Y$，则称$X$函数确定$Y$或$Y$函数依赖$X$，记作$X \\rightarrow Y$。 $X \\rightarrow Y$，但$Y \\nsubseteq X$，则称$X \\rightarrow Y$是非平凡的函数依赖。$X$称为这个函数依赖的决定属性组，也称为决定属性。 $X \\rightarrow Y$，但$Y \\subseteq X$，则称$X \\rightarrow Y$是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。 若$X \\rightarrow Y$，$Y \\rightarrow X$，则记作若$X \\leftarrow \\rightarrow Y$（即直接函数依赖） 若$Y$不函数依赖于$X$，则记作$X \\nrightarrow Y$ 定义：在R(U)中，如果$X \\rightarrow Y$，并且对于$X$的任何一个真子集$X’$，都有$X’ \\nrightarrow Y$，则称$Y$对$X$完全函数依赖，记作$X \\stackrel{F}{\\rightarrow} Y$ 若$X \\rightarrow Y$，但$Y$不完全函数依赖于$X$，则称Y对X部分函数依赖，记作$X \\stackrel{P}{\\rightarrow} Y$ 定义：在R(U)中，如果$X \\rightarrow Y (Y \\nsubseteq X)$，$Y \\nrightarrow X$，$Y \\rightarrow Z$，$Z \\nsubseteq Y$，则称$Z$对$X$传递函数依赖，记作$X \\stackrel{传递}{\\rightarrow} Y$ 码定义：设$K$为$R$中的属性或属性组合，若$K \\stackrel{F}{\\rightarrow} U$，则$K$为$R$的候选码如果$K \\stackrel{P}{\\rightarrow} U$，则$K$称为超码。候选码是最小的超码，即$K$的任何一个真子集都不是候选码包含在任何一个候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性 范式关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式各种范式之间的关系有： 5NF \\subset 4NF \\subset BCNF \\subset 3NF \\subset 2NF \\subset 1NF一个低一级范式的关系模式通过模式分解（schema decomposition）可以转化为若干高一级范式的关系模式的集合，这叫做规范化（normalization） 1NF每个分量（属性）必须是不可分的数据项 2NF相比于1NF，消除了非主属性对码的部分函数依赖定义：设关系模式$R$，若$R \\in 1NF$，且每个非主属性完全函数依赖于任何一个候选码，则$R \\in 2NF$一个关系模式R若不属于2NF，可能会产生：插入异常、删除异常、修改复杂 3NF相比于2NF，消除了非主属性对码的传递函数依赖定义：设关系模式$R$，若$R \\in 3NF$，则每个非主属性既不传递依赖于码，也不部分依赖于码，也就是说，若R属于3NF则必有R属于2NF BCNF相比于3NF，消除了主属性对码的部分和传递函数依赖定义：设关系模式$R$，若每个决定因素都包含码，则$R \\in BCNF$满足BCNF的关系模式的性值： 所有非主属性对每一个码都是完全函数依赖 所有主属性对每一个不包含它的码也是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性 多值依赖&amp;&amp;&amp; 4NF相比于BCNF，消除了非平凡且非函数依赖的多值依赖 规范化小结规范化的基本思想是逐步消除数据依赖中不合适的部分 o1=>operation: 1NF i12=>inputoutput: 消除非主属性对码的部分函数依赖 o2=>operation: 2NF i23=>inputoutput: 消除非主属性对码的传递函数依赖 o3=>operation: 3NF i3b=>inputoutput: 消除主属性对码的部分和传递函数依赖 ob=>operation: BCNF ib4=>inputoutput: 消除非平凡且非函数依赖的多值依赖 o4=>operation: 4NF o1->i12->o2->i23->o3->i3b->ob->ib4->o4{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第五章：数据库完整性","slug":"Database5","date":"2019-04-26T11:42:51.000Z","updated":"2019-05-16T15:28:32.690Z","comments":true,"path":"2019/04/26/Database5/","link":"","permalink":"https://godway999.github.io/2019/04/26/Database5/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 数据库的完整性是指数据的正确性和相容性 实体完整性 关系模式的实体完整性在CREATE TABLE中用PRIMARY KEY定义。 单属性构成的码有两种说明方式：列级约束条件、表级约束条件。 多属性构成的码只有一种说明方式：表级约束 实体完整性检查和违约处理： 检验主码值是否唯一，如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改 12345例：CREATE TABLE XXX( Sno CHAR(20) PRIMARY KEY, /*单属性可以在列级定义主码*/ PRIMARY KEY(Sno,Cno,...), /*多属性只能在表级定义主码*/); 参照完整性 关系模式的参照完整性在CREATE TABLE中用FORIEGN KEY短语定义哪些属性为外码,用REFERENCES指明这些外码参照哪些表的主码。 12345例：CREATE TABLE XXX( Cno CHAR(20), FOREIGN KEY(Cno) REFERENCES Course(Cno), /*在表级定义参照完整性*/); 可能破坏参照完整性的情况及违约处理： 被参照表&lt;=&gt;参照表 违约处理 可能破坏参照完整性&lt;-插入元组 拒绝 可能破坏参照完整性&lt;-修改外码值 拒绝 删除元组-&gt;可能破坏参照完整性 拒绝/级联删除/设为空值 修改主码值-&gt;可能破坏参照完整性 拒绝/级联删除/设为空值 用户定义的完整性用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求。在CREATE TABLE中定义属性的同时，可以根据应用的要求定义属性上的约束条件，即属性值的限制，包括： 列值非空（NOT NULL） 值唯一（UNIQUE） 检查列值是否满足一个条件表达式（CHECK短语） 与属性上约束条件的定义类似，在CREATE TABLE语句中可以用CHECK短语定义元组上的约束条件，即元组级的限制。 12345678例：CREATE TABLE Student( Sno CHAR(9) UNIQUE NOT NULL, /*要求Sno值唯一且不能为空*/ Sname CHAR(8) NOT NULL, Sage int CHECK(Sage &gt;= 15 AND Sage &lt;= 50) /*列级CHECK短语*/ Ssex CHAR(2), CHECK(Ssex=&apos;女&apos; OR Sname NOT LIKE&apos;Ms.%&apos;) /*定义了元组中两个属性值之间的约束*/); 完整性约束命名子句 用完整性约束命名子句CONSTRAINT，用来对完整性约束条件命名，从而便于管理完整性约束条件。 1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK等。 12345678910例：CREATE TABLE Student( Sno NUMERIC(6), Sname CHAR(20), Sage NUMERIC(3) NOT NULL, CONSTRAINT StudentKey PRIMARY KEY(Sno), CONSTRAINT SnameKey FOREIGN KEY(Sname) REFERENCES Course(Sname), CONSTRAINT C1 CHECK(Sno BETWEEN 90000 AND 99999), CONSTRAINT C2 UNIQUE(Sname)); 修改表中的完整性限制，可以先删除原来的约束条件，再增加新的约束条件 12ALTER TABLE &lt;表名&gt; DROP CONSTRAINT &lt;完整性约束条件名&gt;ALTER TABLE &lt;表名&gt; ADD CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; 触发器 触发器(trigger)是用户定义在关系表上的一类由事件驱动的特殊过程。触发器类似于约束，但是比约束更加灵活，可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力 1234567/*触发器一般格式*/CREATE TRIGGER &lt;触发器名&gt;[BEFORE|AFTER] [INSERT|DELETE|UPDATE] ON &lt;表名&gt;FOR EACH [ROW|STATEMENT]BEGIN &lt;执行语句列表&gt;END 例如：建立触发器t1，当插入学生的年龄小于18岁时进行报错提示 123456789101112DELIMITER $ /*告诉mysql语句的结尾符号换成以$结束*/CREATE TRIGGER t1BEFORE INSERT ON StudentFOR EACH ROWBEGIN DECLARE msg VARCHAR(200); IF NEW.Sage &lt; 18 THEN SET msg = CONCAT(&apos;输入的年龄值: &apos;,NEW.Sage,&apos; 为无效的年龄，请确保学生年龄大于18岁&apos;); SIGNAL SQLSTATE &apos;HY000&apos; SET MESSAGE_TEXT = msg; END IF;END$DELIMITER ; /*将结尾符号换回以;结束*/ MySQL 中定义了NEW和OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容，具体地： 在INSERT型触发器中，NEW用来表示将要（BEFORE）或已经（AFTER）插入的新数据 在UPDATE型触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据 在DELETE型触发器中，OLD用来表示将要或已经被删除的原数据 另外OLD是只读的，而NEW则可以在触发器中赋值，这样不会再次触发触发器，导致递归循环调用","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第四章：数据库安全性","slug":"Database4","date":"2019-04-25T11:42:48.000Z","updated":"2019-05-10T02:24:54.778Z","comments":true,"path":"2019/04/25/Database4/","link":"","permalink":"https://godway999.github.io/2019/04/25/Database4/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 用户权限由两个要素组成：数据库对象、操作类型 创建用户12CREATE USER &lt;用户名&gt;@&lt;用户登陆主机&gt; [IDENTIFIED BY &lt;密码&gt;];CREATE USER &lt;用户名&gt;; /*可以在本地无密码登录的账户*/ 用户登录主机若不填写则默认为localhost，若要允许远程登陆，则localhost可以替换为相应的主机ip，或者直接替换为：%（表示任何一台主机都可以远程登陆）。 新用户的密码可以选择不创建。 修改用户密码12ALTER USER &lt;用户名&gt;@&lt;用户登陆主机&gt; IDENTIFIED BY &lt;新密码&gt;SET PASSWORD FOR &lt;用户名&gt;@&lt;用户登陆主机&gt; = PASSWORD(&apos;新密码&apos;) /*创建新密码*/ 删除用户1DROP USER [IF EXIST] &lt;用户名&gt;@&lt;用户登陆主机&gt; 给用户授权1GRANT &lt;权限&gt;(属性名),... ON &lt;数据库名&gt;.&lt;数据库表名&gt;,... TO &lt;用户名&gt;@&lt;用户登陆主机&gt;,... [WITH GRANT OPTION] 如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予其他用户（传播权限） 对于&lt;权限&gt;(属性名)，如UPDATE(Sno)表示对于Sno这个属性具有更新的权限，若不填则默认为所有属性 如果想给新用户所有的权限，可以直接使用ALL PRIVILEGES 收回授权1REVOKE &lt;权限&gt;(属性名),... ON &lt;数据库名&gt;.&lt;数据库表名&gt;,... FROM &lt;用户名&gt;@&lt;用户登陆主机&gt;,... MySQL8.0新增角色管理MySQL 8.0 为了用户权限管理更容易，提供了一个角色管理的新功能。角色是指定的权限集合，和用户帐户一样可以对角色进行权限的授予和撤消。如果用户被授予角色权限，则该用户拥有该角色的权限。MySQL 8.0 提供的角色管理功能如下： 12345678CREATE ROLE 角色创建DROP ROLE 角色删除GRANT 为用户和角色分配权限REVOKE 为用户和角色撤销权限SHOW GRANTS 显示用户和角色的权限SET DEFAULT ROLE 指定哪些帐户角色默认处于活动状态SET ROLE 更改当前会话中的活动角色CURRENT_ROLE() 显示当前会话中的活动角色 创建用户、分配权限、回收权限、验证 创建用户 1CREATE USER wsy@&apos;%&apos; IDENTIFIED BY &apos;111111&apos;; 分配权限 1GRANT INSERT,UPDATE,ALTER ON test.* TO wsy@&apos;%&apos;; 回收权限 1REVOKE UPDATE ON test.* FROM wsy@&apos;%&apos;; 验证 1234567/*使用用户wsy登录Mysql之后*/SELECT user();USE test;DESC P;INSERT INTO P VALUES (&apos;P7&apos;, &apos;螺母&apos;, &apos;绿&apos;, 32);SELECT * FROM P WHERE PNO=&apos;P1&apos;UPDATE P SET P=P+10 WHERE COLOR=&apos;红&apos;; 结果如下 创建角色、分配权限、回收权限、验证 创建角色 1CREATE ROLE visitor; 分配权限 1GRANT SELECT ON test.* TO visitor; 回收权限 1REVOKE SELECT ON test.* FROM visitor; 验证 12345/*root账户下，分配visitor角色给wsy*/GRANT visitor TO wsy;/*使用用户wsy登录Mysql之后*/USE test; 审计功能 开启审计功能 设置变量 12345678/*打开审计开关*/set global general_log = on;set global general_log_file = &apos;/var/lib/mysql/operation.log&apos;;set global log_timestamps = SYSTEM;/*查看审计状态*/show global variables like &apos;log_timestamps&apos;;show global variables like &apos;%general%&apos;; 设置审计权限 创建用于存放连接日志的数据库和表 123456789create database auditlog;create table auditlog.t_audit(id int not null auto_increment,thread_id int not null,login_time timestamp,localname varchar(50) default null,matchname varchar(50) default null,primary key (id))ENGINE=InnoDB default charset=utf8 comment &apos;审计用户登录信息&apos;; 授权某个用户拥有对审计表的select和insert权限 12345/*给出对所有用户授权的语句（拼结授权语句）*/SELECT concat(&quot;GRANT SELECT,INSERT ON auditlog.t_audit to &apos;&quot;,user,&quot;&apos;@&apos;&quot;,host,&quot;&apos;;&quot;) FROM mysql.user;/*授权用户wsy*/GRANT SELECT,INSERT ON auditlog.* to wsy@&apos;%&apos;; 设置init_connect参数 1SET GLOBAL init_connect=&apos;INSERT INTO auditlog.t_audit(id,thread_id,login_time,localname,matchname) VALUES(null,connection_id(),now(),user(),current_user());&apos;; 普通用户登录，执行操作 查看登录记录 1SELECT * FROM t_audit WHERE matchname=&apos;wsy@%&apos;; 执行插入操作 1INSERT INTO P VALUES (&apos;P8&apos;, &apos;丝轴&apos;, &apos;银&apos;, 12); 之后查看日志记录cat /var/lib/mysql/operation.log 可以看到insert操作已经被记录下来 查照操作者 12/*使用root用户*/SELECT * FROM t_audit； 可以看到用户wsy在2019-05-07 19:10:56登录，并在2019-05-07 19:11:11进行了insert操作。","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第三章：关系数据库标准语言SQL","slug":"Database3","date":"2019-04-24T11:42:45.000Z","updated":"2019-05-14T11:04:50.335Z","comments":true,"path":"2019/04/24/Database3/","link":"","permalink":"https://godway999.github.io/2019/04/24/Database3/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 SQL概述SQL 结构化查询语言（Structured Query Language) SQL功能 动词 数据查询 SELECT 数据定义 CREATE，DROP，ALTER 数据操作 INSERT，UPDATE，DELETE 数据控制 GRANT，REVOKE ———后续语句实现基于MySQL——— 数据库的定义与删除 1.定义数据库 1CREATE DATABASE &lt;数据库名&gt;; 2.删除数据库 1DROP DATABASE [IF EXIST] &lt;数据库名&gt;; 基本表的定义、删除与修改 1.定义基本表 12345678CREATE TABLE &lt;表名&gt; (&lt;属性名&gt; &lt;数据类型&gt; [列级完整性约束],&lt;属性名&gt; &lt;数据类型&gt; [列级完整性约束],...[表级完整性约束],[表级完整性约束],...)[CHARSET=utf8]; 2.数据类型 数据类型 含义 CHAR(n) 长度为n的定长字符串 VARCHAR(n) 最大长度为n的变长字符串 TINYBLOB/BLOB/LONGBLOB 不同大小的二进制形式的文本数据 TINYTEXT/TEXT/LONGTEXT 不同大小的文本数据 TINTINT/SMALLINT/BIGINT 不同字节大小的整数 FLOAT/DOUBLE 单/双精度浮点数 DATE 日期值（YYYY-MM-DD） TIME 时间值（HH:MM:SS） YEAR 年份值（YYYY） DATETIME 混合日期和时间值 TIMESTAMP 混合日期和时间值，时间戳 3.修改基本表 12345678910111213141516#增加列（属性）ALTER TABLE &lt;表名&gt; ADD &lt;新属性名&gt; &lt;数据类型&gt; [列级完整性约束];#删除列（属性）ALTER TABLE &lt;表名&gt; DROP &lt;选择的属性名&gt;;#添加表级完整性约束条件ALTER TABLE &lt;表名&gt; ADD [列级完整性约束];#删除键约束ALTER TABLE &lt;表名&gt; DROP PRIMARY KEY;ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;键名&gt;;/*可以通过使用SHOW CREATE TABLE &lt;表名&gt;;来查询外键的键名*/#修改属性的数据类型ALTER TABLE &lt;表名&gt; MODIFY &lt;选择的属性名&gt; &lt;新数据类型&gt;; 4.删除基本表 1DROP TABLE [IF EXIST] &lt;表名&gt;; 索引的建立与删除 1.建立索引 12/*若属性为字符串等类型，可以加上length表示根据前多个字符作为索引，从而节省建立索引的开销*/CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX &lt;索引名&gt; ON &lt;表名&gt;(属性名[(length)],...); 2.删除索引 12ALTER TABLE &lt;表名&gt; DROP INDEX &lt;索引名&gt;;DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;; 3.查看索引 1SHOW INDEX FROM [&lt;数据库名&gt;.]&lt;表名&gt;; 数据字典 数据字典是关系数据库系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。 在进行查询优化和查询处理时，数据字典中的信息是其重要的依据。 数据的查询单表查询 1.选择表中的的若干列 1SELECT [ALL|DISTINCT] &lt;目标属性表达式&gt;,... FROM &lt;表名或视图名&gt;; SECLECT默认使用ALL，表示将结果全部显示。但在有些情况下，投影出来的结果会出现重复行，此时可以用DISTINCT去掉重复行 &lt;目标属性表达式&gt;可以简单的写为目标属性名 如果属性列的显示顺序与在基本表中的顺序相同，也可简单的将&lt;目标属性表达式&gt;指定为 * &lt;目标属性表达式&gt;不仅可以是表中的属性列，也可以是算数表达式、字符串常量、函数等。 用户可以通过指定别名来改变查询结果的列标题 12345678910#查询指定列或全部列SELECT Sname,Sno FROM Student;SELECT * FROM Student;#使用算术表达式、字符串常量和函数SELECT Sname,‘Year of Birth’,2019-Sage,LOWER(Sdept) FROM Student;#使用别名SELECT Sname NAME,‘Year of Birth’ BIRTH,2019-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENT FROM Student; 2.查询满足条件的元组 1SELECT &lt;目标属性表达式&gt;,... FROM &lt;表名或视图名&gt; WHERE &lt;条件表达式&gt;; 查询满足指定条件的元组可以通过WHERE子句实现。例子如下 123456789101112131415161718(1)比较大小SELECT Sname FROM Student WHERE Sdept=&apos;CS&apos;;SELECT DISTINCT Sno FROM SC WHERE Grade&lt;60;(2)确定范围SELECT Sname,Sage FROM Student WHERE Sage [NOT] BETWEEN 20 AND 23;(3)确定集合(谓词IN用来查找属性值属于指定集合的元组)SELECT Sname FROM Student WHERE Sdept IN (&apos;CS&apos;,&apos;MA&apos;,&apos;EE&apos;);(4)字符匹配SELECT * FROM Student WHERE Sname LIKE &apos;刘%&apos;;(5)涉及空值的查询SELECT Sno,Cno FROM SC WHERE Grade IS NULL; /*分数值为空的对应属性*/(6)多重条件查询SELECT Sname FROM Student WHERE Sdept=&apos;CS&apos; AND Sage&lt;20; 谓词LIKE用来进行字符串的匹配,一般格式如下 1[NOT] LIKE &apos;&lt;匹配串&gt;&apos; [ESCAPE &apos;\\&apos;] ESCAPE &#39;\\&#39; 表示’\\’为换码符，用于转义 % 和 &lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符 % 和 ,其中： %(百分号)代表任意长度的字符串。如a%b表示以a开头以b结尾的任意长度的字符串 _(下划线)代表任意单个字符，类似于占位符。如a_b表示以a开头以b结尾长度为3的字符串 注：WHERE子句常用的查询条件表如下 查询条件 谓词 比较 =,&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,!&gt;,!&lt; ; NOT+上述比较运算符 确定范围 BETWEEN AND, NOT BETWEEN AND 确定集合 IN, NOT IN 字符匹配 LIKE, NOT LIKE 空值 IS NULL, IS NOT NULL 多重条件(逻辑运算) AND, OR, NOT 3.ORDER BY子句 可以用ORDER BY子句对查询结果按照一个或多个属性的升序（ASC）或降序（DESC）排列，默认值为升序 用法为ORDER BY &lt;属性名&gt; ASC|DESC 12#例SELECT Sno,Grade FROM SC WHERE Cno=&apos;3&apos; ORDER BY Grade DESC; 4.聚集函数 聚集函数遇到空值时，除了COUNT()外，都跳过空值而只处理非空值 WHERE子句中是不能用聚集函数作为条件表达式的。*聚集函数只能用于SELECT子句和GROUP BY中的HAVING子句 函数名 作用 COUNT(*) 统计元组个数 COUNT([ALL/DISTINCT] &lt;列名&gt;) 统计一列中值的个数 SUM([ALL/DISTINCT] &lt;列名&gt;) 计算一列值的总和(此列必须是数值型) AVG([ALL/DISTINCT] &lt;列名&gt;) 计算一列值的平均值(此列必须是数值型) MAX([ALL/DISTINCT] &lt;列名&gt;) 求一列值中的最大值 MIN([ALL/DISTINCT] &lt;列名&gt;) 求一列值中的最小值 5.GROUP BY子句 GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的作用对象。分组后聚集函数将作用于每组，即每一组都有一个函数值。 WHERE子句与HAVING短语的区别在于作用对象不同。WHERE子句作用于基本表或视图，从中选择满足条件的元组；HAVING短语作用于组，从中选择满足条件的组 1234#例SELECT Cno, COUNT(Sno) FROM SC GROUP BY Cno;SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*) &gt; 3;SELECT Sno, AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade) &gt;= 90; 连接查询 1.等值与非等值连接查询 当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。 注意：若选择的属性列在两个表中是唯一的，则可以省去表名前缀；若不唯一，则引用时必须加上表名前缀。 123456#等值连接SELECT Student.*, SC.* FROM Student, SC WHERE Student.Sno=SC.Sno;#非等值连接SELECT Student.Sno, Sname FROM Student, SC WHEREStudent.Sno=SC.Sno AND SC.Cno=&apos;2&apos; AND SC.Grade&gt;90; 2.自身连接 连接操作不仅可以在两个表之间进行，也可以是一个表与其自身进行连接，称为表的自身连接。 123#例SELECT FIRST.Cno, SECOND.Cpno FROM Course FIRST, Course SECOND WHERE FIRST.Cpno=SECOND.Cno;/*为了区分自身的两个表而给这两个表分别取了别名FIRST和SECOND*/ 3.外连接 两个表进行连接时，若其中一个表没有相关的元组信息，则按普通的两表连接则会省去某些元组，若想保留则可以使用外连接。 12#例SELECT Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno); 4.多表连接 还可以进行两个表以上的连接，称为多表连接。 12#例SELECT Student.Sno, Sname, Cname, Grade FROM Student, SC, Course WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno; 嵌套查询一个SELECT-FROM-WHERE语句称为一个查询块。将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询子查询的SELECT语句不能使用ORDER BY子句，ORDER BY子句只能对最终的查询结果排序子查询的查询条件不依赖于父查询，称为不相关子查询，否则称为相关子查询 1.带有IN谓词的子查询 1234#查询与Sam在同一个系的学生SELECT Sno, Sname, Sdept FROM Student WHERE Sdept IN ( SELECT Sdept FROM Student WHERE Sname=&apos;Sam&apos;); 有些查询可以用连接查询替代，有些是不能替代的 2.带有比较运算符的子查询 1234#查询每个学生超过他自己选修课程平均成绩的课程号（此例为一个相关子查询）SELECT Sno, Cno FROM SC x WHERE Grade &gt;= ( SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); 3.带有ANY(SOME)或ALL谓词的子查询 子查询返回多值时需要使用ANY和ALL谓词修饰。其中：ANY(表示某个)，ALL(表示所有) 123456789#查询非计算机系中比计算机科学系&apos;某个&apos;学生年龄小的学生姓名和年龄SELECT Sname, Sage FROM Student WHERE Sage &lt; ANY ( SELECT Sage FROM Student WHERE Sdept=&apos;CS&apos;) AND Sdept &lt;&gt; &apos;CS&apos;;#查询非计算机系中比计算机科学系&apos;所有&apos;学生年龄小的学生姓名和年龄SELECT Sname, Sage FROM Student WHERE Sage &lt; ALL ( SELECT Sage FROM Student WHERE Sdept=&apos;CS&apos;) AND Sdept &lt;&gt; &apos;CS&apos;; 4.带有EXISTS谓词的子查询 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑结果真值“true”或逻辑假值“false” 1234#查询所有选修了1号课程的学生姓名SELECT Sname FROM Student WHERE EXISTS ( SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=&apos;1&apos;); 集合查询 SQL集合操作包括：并操作UNION、交操作INTERSECT、差操作EXCEPT MySql并没有提供对交和差操作的支持，这里就不再举例 1234#查询计算机科学系的学生及年龄不大于19岁的学生SELECT * FROM Student WHERE Sdept=&apos;CS&apos; UNION SELECT * FROM Student WHERE Sage&lt;=19; 基于派生表的查询 子查询不仅可以出现在WHERE子句中，也可以出现在FROM子句中，这时子查询生成的临时派生表成为主查询的查询对象 1234#例SELECT Sname FROM Student, (SELECT Sno FROM SC WHERE Cno=&apos;1&apos;) AS SC1 WHERE Student.Sno=SC1.Sno; SELECT语句的一般格式 一般格式 12345SELECT [ALL|DISTINCT] &lt;目标属性表达式&gt; [别名],...FROM &lt;表名或视图名&gt;,... | (&lt;子查询&gt;) [AS] &lt;别名&gt;[WHERE &lt;&gt;][GROUP BY &lt;属性名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;属性名2&gt; [ASC|DESC]]; &lt;子查询&gt;由SELECT语句构成 目标属性表达式的可选格式： * &lt;表名&gt;.* COUNT([DISTINCT] *) [&lt;表名&gt;.]&lt;属性名表达式&gt;,… 其中，属性名表达式可以是由属性名、作用于属性的聚集函数和常量的任意算数运算（+，-，*，/）组成的运算公式 聚集函数的一般格式 COUNT|SUM|AVG|MAX|MIN( [DISTINCT|ALL] &lt;属性名&gt; ) WHERE子句的条件表达式的可选格式 &lt;属性名&gt; $\\theta$ &lt;属性名&gt;|&lt;常量&gt;|[ALL|ANY](子查询) &lt;属性名&gt; [NOT] BETWEEN &lt;属性名&gt;|&lt;常量&gt;|(&lt;子查询&gt;) AND &lt;属性名&gt;|&lt;常量&gt;|(&lt;子查询&gt;) &lt;属性名&gt; [NOT] IN (&lt;值1&gt;, &lt;值2&gt;, …)|(&lt;子查询&gt;) &lt;属性名&gt; NOT LIKE 匹配串 &lt;属性名&gt; IS [NOT] NULL [NOT] EXISTS(&lt;子查询&gt;) &lt;条件表达式&gt; AND|OR &lt;条件表达式&gt; AND|OR … 数据的更新 1.插入数据 12345678910111213# 插入元组INSERT INTO &lt;表名&gt;[(&lt;属性名&gt;,...)]VALUES (&lt;对应属性的常量&gt;,...);# 插入子查询结果（建立一个新表）INSERT INTO &lt;新的表名&gt;[(&lt;属性名&gt;,...)]&lt;子查询&gt;;# 例：对每一个系，求学生的平均年龄，并把结果存入新数据表INSERT INTO Dept_age(Sdept, Avg_age) ( SELECT Sdept,AVG(Sage) FROM Student GTOUP BY Sdept); 2.修改数据 123456789101112UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt;,...[WHERE &lt;条件&gt;|&lt;子查询&gt;];# 例：将计算机科学系全体学生的成绩置为零UPDATE SCSET Grade=0WHERE Sno IN ( SELECT Sno FROM Student WHERE Sdept=&apos;CS&apos;); 3.删除数据 DELETE语句删除的是表中的数据，而不是关于表的定义，表的定义仍在字典中。 123456789101112DELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;|&lt;子查询&gt;];# 例：删除计算机科学系全体学生的选课记录（SC表）DELETEFROM SCWHERE Sno IN ( SELECT Sno FROM Student WHERE Sdept=&apos;CS&apos;); 视图 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表 1.建立视图 123CREATE VIEW &lt;视图名&gt;[(&lt;属性名&gt;,...)]AS &lt;子查询&gt;[WITH [CASCADED|LOCAL] CHECK OPTION]; &lt;子查询&gt;可以是任意的SELECT语句。 WITH [CASCADED|LOCAL] CHECK OPTION表示对视图进行UPDATE、INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。 组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。但在下列三种情况下必须明确指明： 1. 某个目标列不是单纯的属性名，而是聚集函数或列表达式 2. 多表连接时选出了几个同名列作为视图的字段 3. 需要在视图中为某个列启用新的更合适的名字 关系数据库管理系统执行CREATE VIEW语句的结果，只是把视图的定义存入数据字典，并不执行其中的SELECT语句。 定义：若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但是保留了主码，则称这类视图为行列子视图。 2.删除视图 1DROP VIEW &lt;视图名&gt; [CASCADE]; 视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用CASCADE级联删除语句一起删除。 3.查询视图 从数据字典中取出视图的定义，将其转换成等价的对基本表的操作后再执行，这一转换过程称为视图消解。 12#使用定义的视图IS_Student进行查询年龄小于20岁的学生SELECT Sno, Sage FROM IS_Student WHERE Sage&lt;20; 4.更新视图 对试图的更新最终要转换为对基本表的更新，但不是所有的视图都是可更新的，一般的，行列子集视图是可更新的。 12#例：将信息系学生视图IS_Student中学号为“201215125”的学生姓名改为“lili”UPDATE IS_Student SET Sname=&apos;lili&apos; WHERE Sno=&apos;201215125&apos;; 5.视图的作用 视图能够简化用户的操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 适当利用视图可以更清晰地表达查询","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第二章：关系数据库","slug":"Database2","date":"2019-04-22T11:40:06.000Z","updated":"2019-05-10T02:24:37.868Z","comments":true,"path":"2019/04/22/Database2/","link":"","permalink":"https://godway999.github.io/2019/04/22/Database2/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 关系 域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域 一个域允许的不同取值个数称为这个域的基数 某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为候选码 若一个关系中有多个候选码，则选定其中一个为主码 关系模式的所有属性是这个关系模式的候选码，称为全码元组：表中的一行码：表中的某个属性组，它可以唯一确定一个元组 关系模式定义： 关系的描述称为关系模式。它可以形式化的表示为R（U，D，DOM，F）其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合 关系的完整性 实体完整性若属性A是基本关系R的主属性，则A不能取空值 参照完整性设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中的每个元组在F上的值必须： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 用户定义的完整性用户定义的完整性就是针对某一具体的关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义条件 关系操作常用的关系操作：查询和插入、删除和修改传统的集合运算：并、差、交、笛卡尔积专门的关系运算：选择、投影、连接、除运算 专门的关系运算 选择（取行）选择又称为限制。它是在关系R中选择满足给定条件的诸元组 投影（取列）从R中选择出若干属性列组成新的关系投影后可能会取消某些元组，因为取消了某些属性列之后可能会出现重复行，应取消相同行 连接它从两个关系的笛卡尔积中选取属性间满足一定条件的元组*自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉 在做自然连接时，可能会舍弃某些元组，这些元组被称为悬浮元组* 除运算（还是去看书吧。。。）设关系R处以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有的组合都在R中","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第一章：绪论","slug":"Database1","date":"2019-04-21T03:14:24.000Z","updated":"2019-05-10T02:24:29.035Z","comments":true,"path":"2019/04/21/Database1/","link":"","permalink":"https://godway999.github.io/2019/04/21/Database1/","excerpt":"","text":"参考书目《数据库系统概论（第5版）》 术语对比 关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中有表（大表中嵌有小表） 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]}]}