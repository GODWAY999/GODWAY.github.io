{"meta":{"title":"Godway's Studio","subtitle":"wsy","description":"","author":"Godway","url":"https://godway999.github.io","root":"/"},"pages":[{"title":"about","date":"2019-04-12T16:00:43.000Z","updated":"2019-04-15T13:07:03.000Z","comments":true,"path":"about/index.html","permalink":"https://godway999.github.io/about/index.html","excerpt":"","text":"HelloWelcome to my studio!"},{"title":"Categories","date":"2019-05-03T13:47:27.000Z","updated":"2019-05-03T14:05:15.097Z","comments":true,"path":"categories/index.html","permalink":"https://godway999.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-03T13:44:33.000Z","updated":"2019-05-03T15:27:54.822Z","comments":true,"path":"tags/index.html","permalink":"https://godway999.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2019-05-04T04:34:39.000Z","updated":"2019-05-04T04:38:18.360Z","comments":true,"path":"2019/05/04/test/","link":"","permalink":"https://godway999.github.io/2019/05/04/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mac本地用Eclipse配置NS3开发环境(完整教程)","slug":"NS3_1","date":"2019-05-03T13:48:29.000Z","updated":"2019-05-04T04:28:04.454Z","comments":true,"path":"2019/05/03/NS3_1/","link":"","permalink":"https://godway999.github.io/2019/05/03/NS3_1/","excerpt":"","text":"前言 这段时间接触了NS3，发现这个框架在计算机网络领域用的还是蛮多的，在本地搭建开发环境的过程中也遇到了不少坑，这里记录一下整个过程。 在终端下编译和运行NS3程序 NS3的下载和编译NS3官网上给的过程已经很详细了，这里简要概述一下。官放一共提供了三种方法:build.py,bake,waf个人推荐使用waf编译整个项目（官方文件中自带waf编译器），因为前两种涉及到好多python环境的依赖，我觉得容易出问题。 在我的Mac上由于使用clang++，一定要加上--disable-werror，如果需要搭建python3的开发环境，需要指明python3具体位置。 123cd (本地存放位置)/ns-allinone-3.29/ns-3.29/./waf --enable-test --build-profile=debug --python=/usr/local/bin/python3 --with-python=python3 --disable-werror configure./waf build 经过一段时间的编译之后，在当前目录下运行一个官方例程scratch-simulator，如果一切顺利可以看到程序输出一行Scratch Simulator 1./waf --run scratch/scratch-simulator 在Eclipse上配置NS3开发环境 作为一个新手，如果没有一个友好的开发环境，很容易就进入从入门到放弃的阶段。NS3最让我不能接受的是必须用官方给的waf编译代码，我一开始尝试在Xcode搭建环境，然而Xcode好像对于使用外部编译器的支持不是很好，最终我还是转到在Eclipse上搭建开发环境。 在Eclipse上新建项目按如下顺序File -&gt; New -&gt; C/C++ Project，创建C++项目着重强调！！！NS3的代码必须放到(本地存放位置)/ns-allinone-3.29/ns-3.29/scratch/文件夹下才能被正确编译执行所以工程位置放在(本地存放位置)/ns-allinone-3.29/ns-3.29/,这里工程名字自己定，我这里取名为NS3，右侧的编译器随便选一个，之后点finish完成。 编译NS3项目如果前一步没遇到问题，现在左侧的工程目录应该基本长这样子，以后就直接在scratch目录下新创xxx.cc文件就好了。之后这里右键NS3文件夹，进入工程属性面板。右侧点击C/C++ Build然后照我的样子配置两处。编译器类型记得选为外部编译器，编译器选为当前目录下的waf编译器，编译结果放在当前目录下的build文件夹中之后进入到(本地存放位置)/ns-allinone-3.29/ns-3.29/进行configure操作，如果之前已经configure过了可以跳过该步骤。 12cd (本地存放位置)/ns-allinone-3.29/ns-3.29/./waf --enable-test --build-profile=debug --python=/usr/local/bin/python3 --with-python=python3 --disable-werror configure configure过了之后点击Eclipse左上角的Build按钮就可以编译整个NS3工程了 配置Eclipse使用外部编译器waf构建完了整个NS3工程之后，我们后续怎么运行我们自己写的代码呢？这时候需要配置使用外部编译器waf。在Eclipse顶部按如下顺序Run -&gt; Extern Tools -&gt; Extern Tools Configurations左侧右键点击新建一个编译器。我这里将这个外部编译器取名为ns3-waf，其余两个和之前一样，参数这里填写--run &quot;${string_prompt}&quot;这里点掉这个Build before launch选项之后点击Eclipse上方红色方框内的按钮然后会弹出一个选项框让填写你要编译的文件的名称，注意这里不用加.cc后缀,比如我要编译运行scratch文件夹下的scratch-simulator.cc，就直接填写scratch-simulator或scratch/scratch-simulator。如果你的自己写的文件之前已经build过了，就不需要再加文件目录scratch/，直接填写文件名就好。下方显示运行结果 配置NS工程路径此时虽然能够运行自己写的NS3代码了，但是代码中却还有一堆烦人的下波浪线〰️，并且头文件的引用等都是查询不到的，这里就需要配置一下NS3工程路径和环境。和之前一样，首先进入属性面板。然后找到图中所示的配置目录这一步将(本地存放位置)/ns-allinone-3.29/ns-3.29/build/ns3/下所有工程头文件包含了进来。然后构建会花费一小会时间，之后可以在左侧NS3/includes/下看到新生成了一个NS3/build/ns3文件，然后代码中的波浪线就全部消失了 配置完成","categories":[{"name":"NS3","slug":"NS3","permalink":"https://godway999.github.io/categories/NS3/"}],"tags":[]},{"title":"数据库原理——第七章：数据库设计","slug":"Database7","date":"2019-05-03T11:42:57.000Z","updated":"2019-05-03T13:54:29.563Z","comments":true,"path":"2019/05/03/Database7/","link":"","permalink":"https://godway999.github.io/2019/05/03/Database7/","excerpt":"","text":"","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第六章：关系数据库理论","slug":"Database6","date":"2019-04-27T11:42:54.000Z","updated":"2019-05-03T14:06:13.531Z","comments":true,"path":"2019/04/27/Database6/","link":"","permalink":"https://godway999.github.io/2019/04/27/Database6/","excerpt":"","text":"问题的提出 针对一个具体的问题，应该如何构建一个适用于它的数据库模式，即应该构建几个关系模式，每个关系由哪些属性组成等。这是数据库设计的问题，确切地讲是关系数据库逻辑设计问题（如何构造合适的数据模式）。 数据依赖是一个关系内部属性与属性之间的约束关系，这种约束关系是通过属性值的相等与否体现出来的数据间相关联系。 一个好的关系模式不会发生插入异常、删除异常和更新异常，数据冗余尽可能的少。 规范化 若属性组X能唯一确定属性组Y，则称X函数确定Y或Y函数依赖X，记作$X \\rightarrow Y$。 $X \\rightarrow Y$，但$Y \\nsubseteq X$，则称$X \\rightarrow Y$是非平凡的函数依赖。 $\\nsubseteq$ $\\nrightarrow$","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第五章：数据库完整性","slug":"Database5","date":"2019-04-26T11:42:51.000Z","updated":"2019-05-03T14:06:02.843Z","comments":true,"path":"2019/04/26/Database5/","link":"","permalink":"https://godway999.github.io/2019/04/26/Database5/","excerpt":"","text":"数据库的完整性是指数据的正确性和相容性 实体完整性 关系模式的实体完整性在CREATE TABLE中用PRIMARY KEY定义。 单属性构成的码有两种说明方式：列级约束条件、表级约束条件。 多属性构成的码只有一种说明方式：表级约束 12345例：CREATE TABLE XXX( Sno CHAR(20) PRIMARY KEY, /*单属性可以在列级定义主码*/ PRIMARY KEY(Sno,Cno,...), /*多属性只能在表级定义主码*/) 参照完整性 关系模式的参照完整性在CREATE TABLE中用FORIEGN KEY短语定义哪些属性为外码,用REFERENCES指明这些外码参照哪些表的主码。 12345例：CREATE TABLE XXX( Cno CHAR(20), FOREIGN KEY(Cno) REFERENCES Course(Cno), /*在表级定义参照完整性*/) 用户定义的完整性用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求。在CREATE TABLE中定义属性的同时，可以根据应用的要求定义属性上的约束条件，即属性值的限制，包括： 列值非空（NOT NULL） 值唯一（UNIQUE） 检查列值是否满足一个条件表达式（CHECK短语） 与属性上约束条件的定义类似，在CREATE TABLE语句中可以用CHECK短语定义元组上的约束条件，即元组级的限制。 12345678例：CREATE TABLE Student( Sno CHAR(9) UNIQUE NOT NULL, /*要求Sno值唯一且不能为空*/ Sname CHAR(8) NOT NULL, Sage int CHECK(Sage &gt;= 15 AND Sage &lt;= 50) /*列级CHECK短语*/ Ssex CHAR(2), CHECK(Ssex=&apos;女&apos; OR Sname NOT LIKE&apos;Ms.%&apos;) /*定义了元组中两个属性值之间的约束*/) 完整性约束命名子句 用完整性约束命名子句CONSTRAINT，用来对完整性约束条件命名，从而便于管理完整性约束条件。 1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK等。 12345678例：CREATE TABLE Student( Sno NUMERIC(6) CONSTRAINT C1 CHECK(Sno BETWEEN 90000 AND 99999), Sname CHAR(20) CONSTRAINT C2 UNIQUE, Sage NUMERIC(3) CONSTRAINT C3 NOT NULL, CONSTRAINT StudentKey PRIMARY KEY(Sno), CONSTRAINT SnameKey FOREIGN KEY(Sname) REFERENCES Course(Sname)) 修改表中的完整性限制，可以先删除原来的约束条件，再增加新的约束条件 12ALTER TABLE &lt;表名&gt; DROP CONSTRAINT &lt;完整性约束条件名&gt;ALTER TABLE &lt;表名&gt; ADD CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt; 触发器&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第四章：数据库安全性","slug":"Database4","date":"2019-04-25T11:42:48.000Z","updated":"2019-05-03T14:05:54.565Z","comments":true,"path":"2019/04/25/Database4/","link":"","permalink":"https://godway999.github.io/2019/04/25/Database4/","excerpt":"","text":"用户权限由两个要素组成：数据库对象、操作类型 创建用户12CREATE USER &lt;用户名&gt;@&lt;用户登陆主机&gt; [IDENTIFIED BY &lt;密码&gt;];CREATE USER &lt;用户名&gt;; /*可以在本地无密码登录的账户*/ 用户登录主机若不填写则默认为localhost，若要允许远程登陆，则localhost可以替换为相应的主机ip，或者直接替换为：%（表示任何一台主机都可以远程登陆）。 新用户的密码可以选择不创建。 修改用户密码12ALTER USER &lt;用户名&gt;@&lt;用户登陆主机&gt; IDENTIFIED BY &lt;新密码&gt;SET PASSWORD FOR &lt;用户名&gt;@&lt;用户登陆主机&gt; = PASSWORD(&apos;新密码&apos;) /*创建新密码*/ 删除用户1DROP USER [IF EXIST] &lt;用户名&gt;@&lt;用户登陆主机&gt; 给用户授权1GRANT &lt;权限&gt;(属性名),... ON &lt;数据库名&gt;.&lt;数据库表名&gt;,... TO &lt;用户名&gt;@&lt;用户登陆主机&gt;,... [WITH GRANT OPTION] 如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予其他用户（传播权限） 对于&lt;权限&gt;(属性名)，如UPDATE(Sno)表示对于Sno这个属性具有更新的权限，若不填则默认为所有属性 收回授权1REVOKE &lt;权限&gt;(属性名),... ON &lt;数据库名&gt;.&lt;数据库表名&gt;,... FROM &lt;用户名&gt;@&lt;用户登陆主机&gt;,...","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第三章：关系数据库标准语言SQL","slug":"Database3","date":"2019-04-24T11:42:45.000Z","updated":"2019-05-03T14:05:44.940Z","comments":true,"path":"2019/04/24/Database3/","link":"","permalink":"https://godway999.github.io/2019/04/24/Database3/","excerpt":"","text":"SQL概述SQL 结构化查询语言（Structured Query Language) SQL功能 动词 数据查询 SELECT 数据定义 CREATE，DROP，ALTER 数据操作 INSERT，UPDATE，DELETE 数据控制 GRANT，REVOKE ———后续语句实现基于MySQL——— 数据库的定义与删除 1.定义数据库 1CREATE DATABASE &lt;数据库名&gt;; 2.删除数据库 1DROP DATABASE [IF EXIST] &lt;数据库名&gt;; 基本表的定义、删除与修改 1.定义基本表 12345678CREATE TABLE &lt;表名&gt; (&lt;属性名&gt; &lt;数据类型&gt; [列级完整性约束],&lt;属性名&gt; &lt;数据类型&gt; [列级完整性约束],...[表级完整性约束],[表级完整性约束],...)[CHARSET=utf8]; 2.数据类型 数据类型 含义 CHAR(n) 长度为n的定长字符串 VARCHAR(n) 最大长度为n的变长字符串 TINYBLOB/BLOB/LONGBLOB 不同大小的二进制形式的文本数据 TINYTEXT/TEXT/LONGTEXT 不同大小的文本数据 TINTINT/SMALLINT/BIGINT 不同字节大小的整数 FLOAT/DOUBLE 单/双精度浮点数 DATE 日期值（YYYY-MM-DD） TIME 时间值（HH:MM:SS） YEAR 年份值（YYYY） DATETIME 混合日期和时间值 TIMESTAMP 混合日期和时间值，时间戳 3.修改基本表 1234567891011121314#增加列（属性）ALTER TABLE &lt;表名&gt; ADD &lt;新属性名&gt; &lt;数据类型&gt; [列级完整性约束];#删除列（属性）ALTER TABLE &lt;表名&gt; DROP &lt;选择的属性名&gt;;#添加表级完整性约束条件ALTER TABLE &lt;表名&gt; ADD [列级完整性约束];#删除键约束ALTER TABLE &lt;表名&gt; DROP [FOREIGN KEY / PRIMARY] &lt;键名&gt;;#修改属性的数据类型ALTER TABLE &lt;表名&gt; MODIFY &lt;选择的属性名&gt; &lt;新数据类型&gt;; 4.删除基本表 1DROP TABLE [IF EXIST] &lt;表名&gt;; 索引的建立与删除 1.建立索引 12/*若属性为字符串等类型，可以加上length表示根据前多个字符作为索引，从而节省建立索引的开销*/CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX &lt;索引名&gt; ON &lt;表名&gt;(属性名[(length)],...); 2.删除索引 12ALTER TABLE &lt;表名&gt; DROP INDEX &lt;索引名&gt;;DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;; 3.查看索引 1SHOW INDEX FROM [&lt;数据库名&gt;.]&lt;表名&gt;; 数据字典 数据字典是关系数据库系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。 在进行查询优化和查询处理时，数据字典中的信息是其重要的依据。 数据的查询 一般格式 12345SELECT [ALL|DISTINCT] &lt;目标属性表达式&gt; [别名],...FROM &lt;表名或视图名&gt;,... | (&lt;子查询&gt;) [AS] &lt;别名&gt;[WHERE &lt;&gt;][GROUP BY &lt;属性名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;属性名2&gt; [ASC|DESC]]; &lt;子查询&gt;由SELECT语句构成 目标属性表达式的可选格式： * &lt;表名&gt;.* COUNT([DISTINCT] *) [&lt;表名&gt;.]&lt;属性名表达式&gt;,… 其中，属性名表达式可以是由属性名、作用于属性的聚集函数和常量的任意算数运算（+，-，*，/）组成的运算公式 聚集函数的一般格式 COUNT|SUM|AVG|MAX|MIN( [DISTINCT|ALL] &lt;属性名&gt; ) WHERE子句的条件表达式的可选格式 &lt;属性名&gt; $\\theta$ &lt;属性名&gt;|&lt;常量&gt;|[ALL|ANY](子查询) &lt;属性名&gt; [NOT] BETWEEN &lt;属性名&gt;|&lt;常量&gt;|(&lt;子查询&gt;) AND &lt;属性名&gt;|&lt;常量&gt;|(&lt;子查询&gt;) &lt;属性名&gt; [NOT] IN (&lt;值1&gt;, &lt;值2&gt;, …)|(&lt;子查询&gt;) &lt;属性名&gt; NOT LIKE 匹配串 &lt;属性名&gt; IS [NOT] NULL [NOT] EXISTS(&lt;子查询&gt;) &lt;条件表达式&gt; AND|OR &lt;条件表达式&gt; AND|OR … 数据的更新 1.插入数据 12345678910111213# 插入元组INSERT INTO &lt;表名&gt;[(&lt;属性名&gt;,...)]VALUES (&lt;对应属性的常量&gt;,...);# 插入子查询结果（建立一个新表）INSERT INTO &lt;新的表名&gt;[(&lt;属性名&gt;,...)]&lt;子查询&gt;;# 例：对每一个系，求学生的平均年龄，并把结果存入新数据表INSERT INTO Dept_age(Sdept, Avg_age) ( SELECT Sdept,AVG(Sage) FROM Student GTOUP BY Sdept); 2.修改数据 123456789101112UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt;,..[WHERE &lt;条件&gt;|&lt;子查询&gt;];# 例：将计算机科学系全体学生的成绩置为零UPDATE SCSET Grade=0WHERE Sno IN ( SELECT Sno FROM Student WHERE Sdept=&apos;CS&apos;); 3.删除数据 DELETE语句删除的是表中的数据，而不是关于表的定义，表的定义仍在字典中。 123456789101112DELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;|&lt;子查询&gt;];# 例：删除计算机科学系全体学生的选课记录（SC表）DELETEFROM SCWHERE Sno IN ( SELECT Sno FROM Student WHERE Sdept=&apos;CS&apos;); 视图 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表 1.建立视图 123CREATE VIEW &lt;视图名&gt;[(&lt;属性名&gt;,...)]AS &lt;子查询&gt;[WITH [CASCADED|LOCAL] CHECK OPTION]; &emsp;&emsp;&ensp;&lt;子查询&gt;可以是任意的SELECT语句。&emsp;&emsp;&ensp;WITH [CASCADED|LOCAL] CHECK OPTION表示对视图进行UPDATE、INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。&emsp;&emsp;&ensp;组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。但在下列三种情况下必须明确指明：&emsp;&emsp;&ensp;&emsp;1. 某个目标列不是单纯的属性名，而是聚集函数或列表达式&emsp;&emsp;&ensp;&emsp;2. 多表连接时选出了几个同名列作为视图的字段&emsp;&emsp;&ensp;&emsp;3. 需要在视图中为某个列启用新的更合适的名字&emsp;&emsp;&ensp;关系数据库管理系统执行CREATE VIEW语句的结果，只是把视图的定义存入数据字典，并不执行其中的SELECT语句。&emsp;&emsp;&ensp;定义：若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但是保留了主码，则称这类视图为行列子视图。 2.删除视图 1DROP VIEW &lt;视图名&gt; [CASCADE]; &emsp;&emsp;&ensp;视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用CASCADE级联删除语句一起删除。 3.查询视图 从数据字典中取出视图的定义，将其转换成等价的对基本表的操作后再执行，这一转换过程称为视图消解。 4.更新视图 对试图的更新最终要转换为对基本表的更新，但不是所有的视图都是可更新的，一般的，行列子集视图是可更新的。 5.视图的作用 视图能够简化用户的操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 适当利用视图可以更清晰地表达查询","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第二章：关系数据库","slug":"Database2","date":"2019-04-22T11:40:06.000Z","updated":"2019-05-03T14:05:34.405Z","comments":true,"path":"2019/04/22/Database2/","link":"","permalink":"https://godway999.github.io/2019/04/22/Database2/","excerpt":"","text":"关系 域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域 一个域允许的不同取值个数称为这个域的基数 某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为候选码 若一个关系中有多个候选码，则选定其中一个为主码 关系模式的所有属性是这个关系模式的候选码，称为全码元组：表中的一行码：表中的某个属性组，它可以唯一确定一个元组 关系模式定义： 关系的描述称为关系模式。它可以形式化的表示为R（U，D，DOM，F）其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合 关系的完整性 实体完整性若属性A是基本关系R的主属性，则A不能取空值 参照完整性设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中的每个元组在F上的值必须： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 用户定义的完整性用户定义的完整性就是针对某一具体的关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义条件 关系操作常用的关系操作：查询和插入、删除和修改传统的集合运算：并、差、交、笛卡尔积专门的关系运算：选择、投影、连接、除运算 专门的关系运算 选择（取行）选择又称为限制。它是在关系R中选择满足给定条件的诸元组 投影（取列）从R中选择出若干属性列组成新的关系投影后可能会取消某些元组，因为取消了某些属性列之后可能会出现重复行，应取消相同行 连接它从两个关系的笛卡尔积中选取属性间满足一定条件的元组*自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉 在做自然连接时，可能会舍弃某些元组，这些元组被称为悬浮元组* 除运算（还是去看书吧。。。）设关系R处以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有的组合都在R中","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]},{"title":"数据库原理——第一章：绪论","slug":"Database1","date":"2019-04-21T03:14:24.000Z","updated":"2019-05-03T13:54:37.766Z","comments":true,"path":"2019/04/21/Database1/","link":"","permalink":"https://godway999.github.io/2019/04/21/Database1/","excerpt":"","text":"术语对比 关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中有表（大表中嵌有小表） 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性","categories":[{"name":"数据库原理","slug":"数据库原理","permalink":"https://godway999.github.io/categories/数据库原理/"}],"tags":[]}]}